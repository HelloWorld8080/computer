# 链接和加载

```cpp
#include "compile.h"

void function()
{
}

int main(int argc, char const *argv[])
{
    function();
    return 0;
}
```

```cpp
void function();
```

## 预处理

    gcc $(CFLAGS) $(DEBUG) -E $< -o $@

```cpp
# 0 "compile.cc"
# 1 "/home/steven/source/github/computer/x86_assembly/analysis//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "compile.cc"
# 1 "compile.h" 1

void function();
# 2 "compile.cc" 2

void function()
{
}

int main(int argc, char const *argv[])
{
    function();
    return 0;
}
```

## 编译

- 词法分析
- 语法分析
- 语义分析
- 中间代码生成
- 指令选择
- 寄存器分配

    gcc $(CFLAGS) -S $< -o $@

```s
	.file	"compile.c"
	.text
	.globl	function
	.type	function, @function
function:
	nop
	ret
	.size	function, .-function
	.globl	main
	.type	main, @function
main:
	call	function
	movl	$0, %eax
	ret
	.size	main, .-main
	.ident	"GCC: (GNU) 11.1.0"
	.section	.note.GNU-stack,"",@progbits
```

## 汇编

    gcc $(CFLAGS) $(DEBUG) -c $< -o $@
    as -32 $< -o $@

生成二进制文件

## 链接

    ld -m elf_i386 -static $< -o $@ -e main
	链接的时候会将o文件中的数据段指定内存的存储位置。

生成可执行文件

## gcc 集成环境

	gcc compile.cc -o compile.out --verbose

---

	/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/cc1plus -quiet -v -D_GNU_SOURCE compile.cc -quiet -dumpdir compile.out- -dumpbase compile.cc -dumpbase-ext .cc -mtune=generic -march=x86-64 -version -o /tmp/cciKDCSK.s

---

	as -v --64 -o /tmp/cczjiqmy.o /tmp/cciKDCSK.s


---

```sh
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2
-plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so 
-plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper 
-plugin-opt=-fresolution=/tmp/ccvrMGma.res 
-plugin-opt=-pass-through=-lgcc 
-plugin-opt=-pass-through=-lgcc_s 
-plugin-opt=-pass-through=-lc 
-plugin-opt=-pass-through=-lgcc 
-plugin-opt=-pass-through=-lgcc_s 
--build-id 
--eh-frame-hdr 
--hash-style=gnu 
-m elf_x86_64 
-dynamic-linker 
/lib64/ld-linux-x86-64.so.2 
-pie 
-o compile.out 
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o 
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o 
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o 
-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0 
-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib 
-L/lib/../lib 
-L/usr/lib/../lib 
-L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../.. 
/tmp/cczjiqmy.o 
-lgcc 
--push-state 
--as-needed 
-lgcc_s 
--pop-state 
-lc 
-lgcc 
--push-state 
--as-needed 
-lgcc_s 
--pop-state 
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtendS.o 
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crtn.o
```
---
    nasm file.asm -f elf32 -o flie.o /将asm文件转化为o文件 

---
    readelf -e file.o

---
    objdump -d a.out
---
    objdump -d a.o -M intel /将AT&T格式的h汇编转换为Intel格式

---
    gcc -m32 -S hello.c -o hello.s /将c文件转化为asm文件
    gcc -m32 file.o -static /将o文件转换为可执行文件(默认文件名为a.out) 
    gcc -m32 file.o -static -nostartfiles/在不使用链接器包裹编译为可执行文件 
    gcc -m32 file.o -static -nostartfiles -e main /以main为入口标签(entry symbol)入在不使用链接器包裹编译为可执行文件 
---
    as -32 att.s -o att.o /使用gas将AT&T格式的汇编语言转化为o文件
## 极简内核


